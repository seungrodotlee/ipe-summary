## 모듈의 기본 요소

- 입력
- 출력
- 기능
- 기관: 내부 알고리즘
- 내부자료: 내부 기억장소

## 공통모듈의 원칙

- 정확성
- 명화겅
- 완전성
- 일관성
- 추적성

## 소프트웨어 재사용의 2가지 기본 기술

- 생성중심: 모듈을 찾아 끼워맞춤
- 합성중심: 모듈을 만들어서 조립

## 소프트웨어 모듈 결합도 (결합도 낮은 순)

1. 자료 결합도(Data): 자료 요소만으로 인터페이스 구성, 파라메터만으로 상호작용(Call by Value)
2. 스탬프 결합도(Stamp): 같은 레코드 부분적 공유, 구조적 데이터 전달된 경우
3. 제어 결합도(Control): 처리방법을 제어변수로 전달하는 종속적인 관계 (ex. sort(1) sort(2))
4. 외부 결합도(Extern): 모듈 외부에서 데이터, 프로토콜, 인터페이스 공유
5. 공토 결합도(Common): 모듈이 다른 내부 자료를 참조(Call by Ref)
6. 내용 결합도(Content): 다른 모듈 내부 기능/자료 참조

## 소프트웨어 모듈 응집도 (응집도 낮은 순)

1. 우연적 응집도(Coincidental): 내부 루틴들이 뚜렷한 관계/연관성 없이 묶임
2. 논리적 응집도(Logical): 기능별로 묶임
3. 시간적 응집도(Temporal): 수행시기가 같은 것끼리 묶임
4. 절차적 응집도(Procedure): 입력/처리/출력처럼 수행시기가 순위가 있는 것들끼리 묶임
5. 통신적 응집도(Communication): 작업대상이 같은것끼리 묶임
6. 순차적 응집도(Sequential): 이전명령의 출력값을 다음 명령의 입력 자료로 사용하는 경우
7. 기능적 응집도(Functional): 모듈 내부가 하나의 단일 기능으로 존재, 언어에서 지원보다는 라이브러리들

## 설계 모델링

- 구성요소들의 기능적 특성 모델링: 입출력데이터, 데이터 흐름/변환/저장 등 모델링
- 구성요소들의 동적 특성 모델링: 상태 전의, 데이터 흐름 경로, 사건 발생 순서, 실행 경로 등 모델링

## 구조 모델링 도구

- N-S 도표
  - 논리적 기술에 중점
  - 연속, 선택/다중선택, 반복 등 제어 논리 구조로 표현
  - 임의의 제어 이동 어렵
  - 그래픽 설계 도구
  - 상자 도표
  - 프로그램 구현 쉬움
  - 조건이 복합되어 있는 곳의 처리 시각적으로 명확히 식별

## HIPO 도표

- 가시적 도표: 전체적인 흐름/구조 나타냄
- 총체적 도표(총괄도표): 입력, 처리, 출력 등의 기능을 명확히 표현
- 세부적 도표(상세도표): 총괄 도표를 구체적으로 표현

### HIPO 도표 특징

- 분석/설계 도구로 사용
- 기본 시스템 모델은 입력/처리/출력으로 구성
- 하향식 개발에 적합
- 기능과 자료의 의존관계 동시에 표현
- 보기 쉬움
- 수정/유지보수 용이
- 소규모 프로젝트에 적합

## 다잌스트라의 구조적 설계 방법론

- 순차/선택/반복 구조만을 이용, 복잡도 감소, 읽기/검사/유지보수 쉬움
- 표준화된 설계기법
- 단일 입출력 구조
- 한정된 범위 내에서 GOTO 사용

## 설계 모델의 요소

- 구조모델
  - 정적 요소
    - 구성요소 유형/유형계통
    - 배열 결합 관계
    - 인터페이스
    - 상호작용채널
  - 동적 요소
    - 동적 생성/소멸
    - 동적 결합/연결
    - 위치이동, 복제
- 행위 모델
  - 정적 요소
    - 입출력 데이터/매핑
    - 데이터 흐름 채널
  - 동적 요소
    - 제어
    - 상호작용 프로토콜/실행경로
    - 상태전이
    - 처리/입출력 순서
    - 알고리즘

## 시스템 아키텍처 설계

- 시스템 아키텍처 설계는 소프트웨어 아키텍처 설계에 제약을 하는 상위 설계
- 소프트웨어 아키텍처 설계는 소프트웨어 상세 설계 결정을 제약
- 시스템 아키텍처 설계는 전체적 아키텍처 설계, 인터페이스 정의, 사용자 정의 인터페이스 설계 등을 수행
- 소프트웨어 아키텍처 설계는 모듈/컴포넌트 설계 등을 수행
  
## 소프트웨어 아키텍처

- 소프트웨어 골격-기본구조
- 구조적, 비구조적 틀 제공
- 아키텍처는 전체 시스템 구조, 설계 모형을 재사용할 때 사용
- 디자인패턴은 구현 단계에서 해결 방안까지도 제공
- 아키텍처는 모든 종류의 시스템에 적용 가능, 디자인 패턴은 일관된 문제에 적용
- 소프트웨어 품질 요구사항은 소프트웨어 아키텍처를 결정하는데 중요한 요소로 작용

## 소프트웨어 아키텍처 설계

- 소프트웨어 아키텍처 설계는 요구사항들만으로 만들어짐
- 요구사항 중 아키텍처에 영향을 주는 요구사항을 아키텍처 드라이버라고 함
- 아키텍처 드라이버는 입력물
- 태스크에 의해 아키텍처 설계 진행
- 아키텍처 문서, 아키텍처 가이드라인이 결과물

## 소프트웨어 아키텍처의 비지니스 품질 속성

- 시장 적시성
- 비용과 이익
- 예상 시스템 수명
- 목표 시장
- 신규 발매 일정 또는 공개 일정
- 기존 시스템과의 통합

## 계층화 패턴

- 기능을 분리한 계층
  - 표현계층-UI 계층
  - 프로세스 계층-서비스 계층
  - 비즈니스 논리 계층-도메인 계층
  - 데이터 접근 계층-영속 계층
- N-티어 패턴
  - 1티어: 3가지 기능을 한 클라이언트 서버 컴퓨터에 설치/운영
  - 2티어: 데이터베이스는 서버 컴퓨터에, 나머지 2개는 클라이언트 컴퓨터에 분리
  - 3티어: 3개의 컴퓨터 시스템에 기능을 각각 분리시켜 운영

## 클라이언트/서버 패턴

- 이메일, 문서공유, 은행 등에 활용
- 병목현상 저하, 결합력 약함
- 보안 취약, 응용 프로그램 복잡

## 마스터/슬레이브 패턴

- 마스터가 슬레이브에게 작업 분산, 슬레이브가 처리한 결과로 최종 결과 계산
- 마스터 데이터베이스는 원본 데이터, 슬레이브는 복제본을 동기화 하는 형태로 활용 가능

## 파이프-필터 패턴

- 데이터 스트림 생성/처리 시스템에서 사용
- 서브 시스템 간 입력 데이터 받아 처리, 결과를 다음 서브 시스템으로 넘겨주는 과정 반복
- 처리 과정은 필터를 통해 이루어짐, 데이터 스트림은 파이프를 통해 흐름
- 버퍼링 또는 동기화 목적으로 사용
- 컴파일러, 연속한 필터들은 어휘 분석, 파싱 등에 활용

## 브로커 패턴

- 분산 시스템에 사용
- 원격 서비스 실행을 통해 상호 작용
- 서버는 기능을 브로커에 넘겨줌, 클라이언트는 브로커에 서비스 요청
- 웹 서버, 메시지 브로커 모듈 등에 활용

## 피어 투 피어

- 피어는 다른 피어에게 서비스 요청/제공 둘 다 가능
- 파일 공유 네트워크 등에 활용

## 이벤트 버스 패턴

- 알림 서비스 등에 활용
- 4가지 주요 컴포넌트
  - 이벤트 소스
  - 이벤트 리스너
  - 채널
  - 이벤트 버스

## MVC 패턴

- 사용자 인터페이스와 비즈니스 로직 분리, 인터페이스가 변경에 영향을 덜 받도록 만든 모델
- 여러 개의 서브 시스템을 사용하는 경우에 적합
- MVC
  - Model: 데이터, 인터페이스의 영향을 받지 않음, 데이터 변화가 있을 때 뷰와 컨트롤러에 통보, 최신정보 유지
  - View: 사용자에게 데이터를 보여주는 ui 부분
  - Controller
    - 데이터와 비즈니스 로직 사이 상호 동작 관리
    - 뷰에서 나온 사용자 요청 모델에 전달, 모델에게 받은 응답 사용자에게 돌려주는 역할
    - 컨트롤러는 모델의 변화에 따른 적용 가능한 명령을 추가, 삭제, 수정할 수 있음

## 블랙보드 패턴

- 3가지 주요 컴포넌트
  - 블랙보드: 소스 저장 메모리
  - 지식소스: 블랙보드에 저장된 데이터
  - 제어 컴포넌트: 모듈 선택/설정/실행
- 모든 컴포넌트는 블랙보드로 접근, 소스 저장
- 제어 컴포넌트는 블랙보드에 추가되는 새로운 데이터 저장
- 제어 컴포넌트는 블랙보드에서 기존 지식 소스와의 패턴 매칭으로 특정 데이터를 찾음
- 음성 인식, 차량 식별 및 추적 등에 활용

## 인터프리터 패턴

- 특정 언어, 명령어를 해석하는 컴포넌트 설계에 사용

## 코드의 기능

- 3대 기능
  - 식별
  - 분류
  - 배열
- 추가 기능
  - 간소화
  - 표준화
  - 연상
  - 암호화
  - 오류검출

## 코드 설계의 원칙

- 적은 자릿수
- 고유성
- 정렬/분류 편리성
- 적응성/확장성
- 기계처리의 용이성
- 표의성

## 코드의 특성

- 단순성
- 표의성
- 분류성
- 용이성
- 고유성
- 확장성
- 영속성
- 편리성

## 코드 설계

- 고려사항
  - 청보 체계화/처리효율성/호환성/표준화 유무 고려
  - 갱신 용이
  - 추가확장 용이
  - 1:1 대응
- 코드화 대상에 대한 특성 파악의 내용
  - 코드 변경 여부 및 변경 주기 파악
  - 대상 항목 추가/삭제 비율 파악
  - 사용 범위 파악
  - 폐기 되는 코드의 취급 여부 파악
  - 중요성 정도 파악
  - 기간변경 여부 파악
  - 사용경로/실체 차이점 파악


## 코드화 방식 결정 시 고려사항

- 코드 체계
- 체크 디지트 사용 여부
- 코드 자릿수
- 코드화 부여 요령

## 코드의 유형

- 순차 코드
  - 일련번호 부여하는 방법
  - 코드부여 간단, 추가 용이, 코드 길이 짧다
  - 정렬된 경우 검색 빠르지만 새로운 자료 발생시 중간에 끼워 넣어야 하므로 기존 코드의 변화 요구
  - 대상 자료 수 적고 다시 작성하는 경우 없을 때 적합
  - 순서 코드, 일련번호식 코드
- 블록코드
  - 공통 특성을 몇 개의 블록으로 구분하여 부여
  - 적은 자릿수로 많은 항목 표시 가능, 예비 코드 사용 가능
  - 종류 구분 부분만으로 소속 알 수 있음
  - 프로그램 작성시 구분의 크기가 달라 비교 많이 해야 함
  - 구분 순차 코드
- 10진 코드
  - 좌측(자릿수 높은 쪽)은 그룹 분류, 우측(자릿수 낮은 쪽)은 그룹 내 세분화
  - 추가 쉽고, 무한하게 확대 가능
  - 자릿수 많아지고 기계 처리에 불편
  - 하나의 구분에 하나의 코드 - 분류 체제 명확
  - 세부 구분을 10개 이상으로 분류 불가능
  - 도서분류식 코드
- 그룹 분류 코드
  - 전체 대상을 대분류, 중분류, 소분류로 구분, 각 분류별로 개개의 대상을 표현하도록 한 후 합쳐 구성하는 방법
  - 각 그룹 내에서 순차 번호 부여
  - 분류 개수에 제한 두지 않고, 컴퓨터 처리에 가장 적합
  - 분류 체계 명확, 추가 용이
  - 자릿수 비교적 길다
- 연상코드
  - LEDTV-65(65인치 LED TV)같은 거
  - 표의성 뛰어남
- 표의 숫자 코드
  - 대상 항목의 물리적 수치를 이용하여 만든 코드
  - 자릿수 길다
  - 여러 대상 물리적 수치가 같으면 코드값이 같게 됨
  - 같은 종류에 대해서만 코드화 가능

## 파일

### 순차 파일

- 종류
  - 엔트리 순차파일: 레코드 추가순으로 저장
  - 키 순차파일: 레코드에 키 값을 두어, 키 순으로 저장
- 입력 데이터의 논리적 순서에 따라 연속된 위치에 기록
- 기록 밀도 좋음
- 어떤 매체라도 용이하게 사용
- 처리하는데 불편
- 파일 내용 추가/변경/삭제 어려움
- 레코드 접근은 레코드 저장된 물리적 순서 따름
- 검색효율 떨어짐
- 파일 복사, 일괄처리에 사용

### 인덱스 순차 파일

#### 구성

- 인덱스 구역
  - 마스터 인덱스: 대제목
  - 실린더 인덱스: 중제목, 트랙 인덱스에 대한 인덱스
  - 트랙 인덱스: 소제목
- 데이터 구역: 인덱스 값의 논리적 순서에 따라 물리적으로 연속된 위치에 기록
- 오버플로우 구역: 정적 인덱스 편성의 경우 추가 레코드를 기록하는 부분

- 정적 인덱스
  - 파일 레코드 삽입/삭제 시 인덱스 내용은 변화, 파일 구조 자체는 변경되지 않음
- 동적 인덱스
  - 인덱스 파일과 데이터 파일을 블록으로 구성
  - 일정 비율 이상의 빈 공간 만들어 놓음
  - 레코드 개수 유지 못한 블록은 다른 블록과 합병

#### 특징

- 순차처리 랜덤처리 병행 가능
- 레코드 삽입 수정 용이
- 랜덤 편성 파일과 비교해 액세스 시간 느림
- 삽입/삭제가 많아지면 파일 재편성 이루어져야 함

### 랜덤 편성

- 특정한 방법의 키 변화에 의하여 임의로 자료를 보관, 처리 시에도 필요한 장소에 직접 접근하여 원하는 정보 액세스
- 레코드를 키 변환에 따라 직접 처리
- 어떤 레코드라도 평균 접근 시간 내에 접근
- 공간의 낭비
- 충돌 문제 해결 대비해야 함
- 지연시간 있음
- 대화형 처리에 적합
  
